syntax = "proto3";

package UDataPacketImport.GRPC;

/*
service BroadcastProxy
{
    /// Gets the currently available streams.
    rpc GetAvailableStreams(AvailableStreamsRequest) returns(AvailableStreamsResponse) {};
    /// Subscribes to the incoming packets.
    rpc Subscribe(SubscriptionRequest) returns(stream Packet) {};
    /// Subscribes to all available streams.
    //rpc SubscribeToAllStreams(SubscribeToAllStreamsRequest) returns(stream Packet) {};
    /// Unsubscribes from all available streams.
    //rpc UnsubscribeFromAllStreams(UnsubscribeFromAllStreamsRequest) returns(UnsubscribeFromAllStreamsResponse) {};
    rpc Unsubscribe(UnsubscribeRequest) returns(UnsubscribeResponse) {};

    /// Publishes streams to the proxy
    rpc PublishPackets(stream Packet) returns(EndPublicationResponse) {};
}
*/

/// This broadcasts data read from SEEDLink.  Effectively, what is read is
/// immediately forwarded to the consumers.
service SEEDLinkBroadcast
{
    /// Subscribes to the incoming packets.
    rpc Subscribe(SubscribeToAllStreamsRequest) returns(stream Packet) {};
    /// Unsubscirbes from the ihe incoming packet stream.
    //rpc Unsubscribe(UnsubscribeFromAllStreamsRequest) returns(UnsubscribeFromAllStreamsResponse);
}

/*!
 * This is a more nuanced broacast for supporting real-time applications.  As
 * such this utility can attempt to suppress wonky data - future, latent,
 * overlapping, and duplicate data. 
 */
service RealTimeBroadcast
{
    /// Gets the currently available streams.
    rpc GetAvailableStreams(AvailableStreamsRequest) returns(AvailableStreamsResponse) {}; 
    /// Subscribes to all incoming streams.
    rpc SubscribeToAllStreams(SubscribeToAllStreamsRequest) returns(stream Packet) {};
    /// Subscribes to a set of incoming streams.
    rpc Subscribe(SubscriptionRequest) returns(stream Packet) {}; 
}

/*!
 * A sensor's network code, station name, channel code, and location code.
 * Together this information comprises a unique stream identifier.
 */
message StreamIdentifier
{
    string network = 1; /// The network code - e.g., UU.
    string station = 2; /// The station code - e.g., FORK.
    string channel = 3; /// The channel code - e.g., HHZ.
    optional string location_code = 4; /// The location code - e.g., 01
}

/*!
 * Defines a data packet.  This amounts to a stream identifier, a start time,
 * sampling rate, and data.
 */
message Packet
{
    enum DataType
    {
        Unknown = 0; /// The data type is unkonwn.  This can happen if there is no data.
        Integer32 = 1; /// The data is a vector of int32_t's stored in data32i.
        Double = 2; /// The data is a vector of doubles stored in data64f.
        Float = 3; /// The data is a vector of floats stored in data32f.
        Integer64 = 4; /// The data is a vector of int64_t's stored in data64i.
    }

    StreamIdentifier stream_identifier = 1; /// The packet identifier.
    int64 start_time_mus = 2; /// The packet's start time (UTC) in microseconds since the epoch.
    double sampling_rate = 3; /// The sampling rate in Hz.
    DataType data_type = 4; /// The data type.
    repeated double data64f = 5; /// The double data.
    repeated int64 data64i  = 6; /// The int64_t data.
    repeated int32 data32i  = 7; /// The int32_t data.
    repeated float data32f  = 8; /// The float data.
}


// Requests the available streams in the broadcast.
message AvailableStreamsRequest
{
}

// Subscribe to a specific set of streams.
message SubscriptionRequest
{
   // The stream identifiers to which to subscribe.  These can be identified with a stream request.
   repeated StreamIdentifier streams = 1;
}


// Unsubscribe from all streams.
message UnsubscribeRequest
{
    StreamIdentifier stream_identifier = 1;
}

// Unsubscribe response.
message UnsubscribeResponse
{
    // Identifier of the stream from which the subscription was canceled.
    StreamIdentifier stream_identifier = 1;
    // Number of packets read from this stream.
    uint64 packets_read = 2;
}

// Subscribes to all available streams.
message SubscribeToAllStreamsRequest
{
}

// Request to unsubscribe from all
message UnsubscribeFromAllStreamsRequest
{   
}

// Response to unsubscribing from all
message UnsubscribeFromAllStreamsResponse
{   
    repeated UnsubscribeResponse stream_response = 1;
}


// A closing message for a stream publisher.
message EndPublicationResponse
{
    // Number of packets sent to proxy front end.
    uint64 packets_received = 1;
    // Number of packets successfully propagated in proxy.
    uint64 packets_published = 2; 
}

// Available streams.
message AvailableStreamsResponse
{
    // The available streams.
    repeated StreamIdentifier stream_identifiers = 1;
}

